<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>再次认识V8引擎 | Che's Blog</title><meta name=keywords content><meta name=description content="本文于2020.01.03发表到掘金
 背景 最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。
解释与编译：JS在V8的执行过程 如下图所示，JS在V8的执行过程分为解释和编译两种模式。
分为2种模式的原因主要在于：
 把JS源码解释为字节码，减少机器码占用的内存空间，牺牲时间换空间 优先进行解释，提高代码的启动速度 针对特定的方法（例如高频调用），JIT编译为机器码，保证运行性能 分层解释与编译，保证V8可维护性  如果考虑垃圾回收，执行过程也可以这样表示。
解释器 Ignition 解释器的输入是JS源码，输出是字节码（bytecode）。同时，还会输出Feedback Vector。
像其他解释器一样，Ignition先根据源码构建AST，接着把AST转换成bytecode，最终在VM上解释运行。
设计bytecode 在设计bytecode时，Ignition采用了Registry Machine来表示bytecode。由于bytecode是机器码的一种抽象表示，因此以Registry Machine的形式表示bytecode，可以让bytecode自然而然地被解释运行。
Ignition使用了r0，r1，r2……和一个acc加法寄存器。
举例：
注意看 LdaNamedProperty a0, [0], [4]，LdaNamedProperty对应着读取obj.x的行为，其中，a0映射到obj，[0]映射到x，[4]映射到Feedback Vector，用来做性能优化。
Feedback Vector Ignition在解释JS源码时，会构建Feedback Vector，并共享给TurboFan。Feedback的结构主要包括4点：
 SharedFunctionInfo：闭包的描述信息 Invocation count: 代表这个闭包被执行的次数 Optimized Code: 标记是否存在TurboFan编译出来的优化代码 BinaryOp：记录了闭包输入输出的类型  举例：
function add(x, y) { return x + y } add(1, 2);  - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace - length: 1 SharedFunctionInfo: 0xb5101ea99c9 <SharedFunctionInfo add> Optimized Code: 0 Invocation Count: 1 Profiler Ticks: 0 Slot #0 BinaryOp BinaryOp:SignedSmall 注意看BinaryOp:SignedSmall，它的含义是返回了SignedSmall类型。"><meta name=author content><link rel=canonical href=https://blog.chezs.me/posts/v8-engine-overall/><link href=/assets/css/stylesheet.min.0485cdac0fa954561182e0fee2a01c0f86081e3a79b55aa4038d97e33a8c57ab.css integrity="sha256-BIXNrA+pVFYRguD+4qAcD4YIHjp5tVqkA42X4zqMV6s=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.chezs.me/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chezs.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chezs.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chezs.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.chezs.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><meta property="og:title" content="再次认识V8引擎"><meta property="og:description" content="本文于2020.01.03发表到掘金
 背景 最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。
解释与编译：JS在V8的执行过程 如下图所示，JS在V8的执行过程分为解释和编译两种模式。
分为2种模式的原因主要在于：
 把JS源码解释为字节码，减少机器码占用的内存空间，牺牲时间换空间 优先进行解释，提高代码的启动速度 针对特定的方法（例如高频调用），JIT编译为机器码，保证运行性能 分层解释与编译，保证V8可维护性  如果考虑垃圾回收，执行过程也可以这样表示。
解释器 Ignition 解释器的输入是JS源码，输出是字节码（bytecode）。同时，还会输出Feedback Vector。
像其他解释器一样，Ignition先根据源码构建AST，接着把AST转换成bytecode，最终在VM上解释运行。
设计bytecode 在设计bytecode时，Ignition采用了Registry Machine来表示bytecode。由于bytecode是机器码的一种抽象表示，因此以Registry Machine的形式表示bytecode，可以让bytecode自然而然地被解释运行。
Ignition使用了r0，r1，r2……和一个acc加法寄存器。
举例：
注意看 LdaNamedProperty a0, [0], [4]，LdaNamedProperty对应着读取obj.x的行为，其中，a0映射到obj，[0]映射到x，[4]映射到Feedback Vector，用来做性能优化。
Feedback Vector Ignition在解释JS源码时，会构建Feedback Vector，并共享给TurboFan。Feedback的结构主要包括4点：
 SharedFunctionInfo：闭包的描述信息 Invocation count: 代表这个闭包被执行的次数 Optimized Code: 标记是否存在TurboFan编译出来的优化代码 BinaryOp：记录了闭包输入输出的类型  举例：
function add(x, y) { return x + y } add(1, 2);  - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace - length: 1 SharedFunctionInfo: 0xb5101ea99c9 <SharedFunctionInfo add> Optimized Code: 0 Invocation Count: 1 Profiler Ticks: 0 Slot #0 BinaryOp BinaryOp:SignedSmall 注意看BinaryOp:SignedSmall，它的含义是返回了SignedSmall类型。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chezs.me/posts/v8-engine-overall/"><meta property="article:published_time" content="2021-02-15T22:30:47+08:00"><meta property="article:modified_time" content="2021-02-15T22:30:47+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="再次认识V8引擎"><meta name=twitter:description content="本文于2020.01.03发表到掘金
 背景 最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。
解释与编译：JS在V8的执行过程 如下图所示，JS在V8的执行过程分为解释和编译两种模式。
分为2种模式的原因主要在于：
 把JS源码解释为字节码，减少机器码占用的内存空间，牺牲时间换空间 优先进行解释，提高代码的启动速度 针对特定的方法（例如高频调用），JIT编译为机器码，保证运行性能 分层解释与编译，保证V8可维护性  如果考虑垃圾回收，执行过程也可以这样表示。
解释器 Ignition 解释器的输入是JS源码，输出是字节码（bytecode）。同时，还会输出Feedback Vector。
像其他解释器一样，Ignition先根据源码构建AST，接着把AST转换成bytecode，最终在VM上解释运行。
设计bytecode 在设计bytecode时，Ignition采用了Registry Machine来表示bytecode。由于bytecode是机器码的一种抽象表示，因此以Registry Machine的形式表示bytecode，可以让bytecode自然而然地被解释运行。
Ignition使用了r0，r1，r2……和一个acc加法寄存器。
举例：
注意看 LdaNamedProperty a0, [0], [4]，LdaNamedProperty对应着读取obj.x的行为，其中，a0映射到obj，[0]映射到x，[4]映射到Feedback Vector，用来做性能优化。
Feedback Vector Ignition在解释JS源码时，会构建Feedback Vector，并共享给TurboFan。Feedback的结构主要包括4点：
 SharedFunctionInfo：闭包的描述信息 Invocation count: 代表这个闭包被执行的次数 Optimized Code: 标记是否存在TurboFan编译出来的优化代码 BinaryOp：记录了闭包输入输出的类型  举例：
function add(x, y) { return x + y } add(1, 2);  - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace - length: 1 SharedFunctionInfo: 0xb5101ea99c9 <SharedFunctionInfo add> Optimized Code: 0 Invocation Count: 1 Profiler Ticks: 0 Slot #0 BinaryOp BinaryOp:SignedSmall 注意看BinaryOp:SignedSmall，它的含义是返回了SignedSmall类型。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"再次认识V8引擎","name":"再次认识V8引擎","description":"本文于2020.01.03发表到掘金\n 背景 最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。\n解释与编译：JS在V8的执行过程 如下图所示，JS在V8的执行过程分为解释和编译两种模式。\n分为2种模式的原因主要在于：\n 把JS源码解释为字节码，减少机器码占用的内存空 …","keywords":[],"articleBody":" 本文于2020.01.03发表到掘金\n 背景 最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。\n解释与编译：JS在V8的执行过程 如下图所示，JS在V8的执行过程分为解释和编译两种模式。\n分为2种模式的原因主要在于：\n 把JS源码解释为字节码，减少机器码占用的内存空间，牺牲时间换空间 优先进行解释，提高代码的启动速度 针对特定的方法（例如高频调用），JIT编译为机器码，保证运行性能 分层解释与编译，保证V8可维护性  如果考虑垃圾回收，执行过程也可以这样表示。\n解释器 Ignition 解释器的输入是JS源码，输出是字节码（bytecode）。同时，还会输出Feedback Vector。\n像其他解释器一样，Ignition先根据源码构建AST，接着把AST转换成bytecode，最终在VM上解释运行。\n设计bytecode 在设计bytecode时，Ignition采用了Registry Machine来表示bytecode。由于bytecode是机器码的一种抽象表示，因此以Registry Machine的形式表示bytecode，可以让bytecode自然而然地被解释运行。\nIgnition使用了r0，r1，r2……和一个acc加法寄存器。\n举例：\n注意看 LdaNamedProperty a0, [0], [4]，LdaNamedProperty对应着读取obj.x的行为，其中，a0映射到obj，[0]映射到x，[4]映射到Feedback Vector，用来做性能优化。\nFeedback Vector Ignition在解释JS源码时，会构建Feedback Vector，并共享给TurboFan。Feedback的结构主要包括4点：\n SharedFunctionInfo：闭包的描述信息 Invocation count: 代表这个闭包被执行的次数 Optimized Code: 标记是否存在TurboFan编译出来的优化代码 BinaryOp：记录了闭包输入输出的类型  举例：\nfunction add(x, y) { return x + y } add(1, 2);  - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace - length: 1 SharedFunctionInfo: 0xb5101ea99c9 Optimized Code: 0 Invocation Count: 1 Profiler Ticks: 0 Slot #0 BinaryOp BinaryOp:SignedSmall 注意看BinaryOp:SignedSmall，它的含义是返回了SignedSmall类型。\nfunction add(x, y) { return x + y; } add(1, 2); add(1.1, 2.2);  - feedback vector: 0x3fd6ea9ef9: [FeedbackVector] in OldSpace - length: 1 SharedFunctionInfo: 0x3fd6ea9989 Optimized Code: 0 Invocation Count: 2 Profiler Ticks: 0 Slot #0 BinaryOp BinaryOp:Number 当我们用不同的参数再次调用add方法后，Feedback Vector产生了变化。BinaryOp:Number变成了Number。由于JS是动态类型语言，做加法是会做类型转换，因此Feedback Vector会认为它降级到了Number类型。\nFeedback Vector是非常重要的描述信息，它描述了编译优化这个闭包的优先级（Invocation Count），以及闭包的数据类型（BinaryOp）。这些信息将被作为TurboFan的输入，编译优化bytecode。\n编译器 TurboFan 编译器的输入是bytecode + Feedback Vector，输出是机器码（machine code）\n类型推断（Speculative Optimization） 类型推断是TurboFan的核心思想。由于JS是动态类型语言，准确对参数做类型推断，能够从2方面改善性能：\n 读取字段：读取obj.x时，如果能推断obj的类型，就能直接知道x在内存中的偏移量，减少寻址次数； 类型转换：a + b时，JS会做类型转换，包含一系列的判断逻辑。如果能推断a、b的类型，就能跳过不必要的逻辑。  编译过程 在Ignition构造bytecode和Feedback Vector后，TurboFan可以生成机器码了。\n总体流程如下图所示。\n在编译器前端，bytecode以Sea of Nodes的形式表达，再生成内联。\n在机器码优化阶段，会做传统优化、消除冗余、逃逸分析、表示选择。\n在编译器后端，主要在机器层面做机器码的再次优化和调度执行。\n此外，从V8源码和一些论文中，我们发现TurboFan会使用LLVM、Emscripten、Binaryen、WABT作为JIT编译器。\nSea of Nodes示例：\n编译优化技术 把Ignition和TurboFan结合起来，V8可以实现的编译优化技术包括： Hidden Class， Inline Caching， OSR（On Stack Replacement）\nHidden Class 隐藏类 Hidden Class就是著名的鸭子模型。Hidden Class是动态创建的，按照配置属性的顺序，以链式构造一系列Hidden Class。举例：\nfunction Point(x, y) { this.x = x; this.y = y; } var p1 = new Point(1, 2); var p2 = new Point(2, 3); 若用不同的顺序配置同名属性，实际上会构造不同的Hidden Class。因此，按顺序配置属性式很重要的工作。\nInline Caching 内联缓存 通常，访问对象属性的过程是：Step1 获取Hidden Class的地址，Step2 根据属性名查找偏移量，Step3 从该属性的地址访问数据。\n虽然Hidden Class使引擎无需遍历所有属性，但仍然比较耗时。\nInline Caching的思路就是将上一次访问的Hidden Class和偏移量缓存起来，当下次访问时，V8断言Hidden Class和字段名和上次访问相同，直接尝试访问对应的地址。因此提高了性能。若断言失败，则回退到一般方式。\nOSR (On Stack Replacement) 有时候，V8会执行一些耗时非常长的方法。因此编译后的代码可能会在方法结束之前就被编译出来。那么，V8会把执行到一半的上下文，用OSR技术发送给编译后的代码，并继续执行。这部分逻辑比较复杂，可以参考：https://wingolog.org/archives/2011/06/20/on-stack-replacement-in-v8\n内存管理 与 垃圾回收 和Java GC相似，V8使用了年轻代和年老代来实现GC。\n年轻代中的GC主要采用Scavenge算法，通过复制对象实现GC。\n 它将Heap分为2个semi space，一个处于使用中（From），一个处于空闲（To）。\n分配对象时，在From空间中分配；GC时，把From空间中存活的对象复制到To空间，并释放From的非存活对象，复制完成后，From和To互换。从GC根节点开始遍历，按照引用来标记存活的对象。\n当对象经过几次GC后仍然存活，或To空间的内存占用超过限制，年轻代的对象会晋升到年老代\n 年老代中的GC主要用标记-清除法。\n 标记过程与年轻代的标记过程相同，遍历GC Root做标记。\n清除过程把所有非存活的对象释放。\n 其他 fast / slow properties\n功能扩展\nV8 Debug工具\n快照\nwasm\n其他Refs https://fhinkel.rocks/2017/08/16/Understanding-V8-s-Bytecode/\nhttps://zhuanlan.zhihu.com/p/28590489\nhttps://docs.google.com/presentation/d/1chhN90uB8yPaIhx_h2M3lPyxPgdPmkADqSNAoXYQiVE/edit#slide=id.g1357e6d1a4_0_58\nhttps://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8\nhttps://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition\nhttps://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E/edit\nhttps://codeburst.io/node-js-v8-internals-an-illustrative-primer-83766e983bf6\nhttps://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\nhttps://zhuanlan.zhihu.com/p/27628685\nV8 与 React Native React Native模块概述 下图右侧是新版React Native的架构图，可以看到，React JS代码经过JSI解释，下发给Fabric、Turbo Modules，最终在Native上执行。\nV8 与 JSI (JavaScript Interface) JSI是一个精简的JS引擎接口：\n 与其使用桥来做消息传递，新的架构允许开发者直接“调用”Java/ObjC的方法（类似RPC）。\n就像我们在浏览器调用DOM方法一样，如果声明var el = document.createElement('div');，变量el是一个C++实现的引用，而不是JS对象。当JS调用el.setAttribute('width', 100)，浏览器同步调用了C++的setWidth方法，最终改变了元素的宽度。\n在React Native中，我们同样使用了JSI来调用Java/ObjC方法。\n RN实现了基本的JS Runtime：https://github.com/facebook/react-native/blob/master/ReactCommon/jsi/jsi/jsi.h\n可以需要开发Native模块，来丰富JSI的能力，例如：http://blog.nparashuram.com/2019/01/react-natives-new-architecture-glossary.html#jsi\n在此基础上，我们就可以用V8Runtime来继承默认的JS Runtime！！！例如：https://github.com/Kudo/react-native-v8/blob/master/src/v8runtime/V8Runtime.h\nC++: truly cross-platform language 😂\nV8与Hermes Hermes的设计目标：针对移动端RN应用做性能优化，降低：\n  App可用时间（TTI）：提升一倍时间效率，Stock RN 4.30s，Hermes RN 2.01s\n  包大小：减少50%的大小，Stock RN 41mb，Hermes RN 22mb\n  内存利用率：节省30%的内存使用，Stock RN 185mb，Hermes RN 136mb\n  关键设计思想：移动端的特点是较小的RAM和较慢的flash IO，因此RN团队决定在build阶段改进Parse和Compile！\n  字节码预编译：按需加载字节码，改善TTI；内存以只读方式映射 ，改善内存占用\n  无JIT编译器：改善TTI、内存消耗，用强大的解释器弥补缺少JIT编译器的损失\n  垃圾回收策略：按前两点的需求改进垃圾回收策略，同时每次GC不扫描整个JS Heap，减少GC时间\n  Hermes 和 V8 的一些性能对比：https://www.infoq.cn/article/ZPhAQPA0uqKyb5hT*i3p\n其他Refs https://formidable.com/blog/2019/jsi-jsc-part-2/\nhttps://engineering.fb.com/android/hermes/\n","wordCount":"312","inLanguage":"en","datePublished":"2021-02-15T22:30:47+08:00","dateModified":"2021-02-15T22:30:47+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chezs.me/posts/v8-engine-overall/"},"publisher":{"@type":"Organization","name":"Che's Blog","logo":{"@type":"ImageObject","url":"https://blog.chezs.me/images/favicon.ico"}}}</script></head><body class=dark id=top><script>if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://blog.chezs.me/ accesskey=h title="Che's Blog (Alt + H)"><img src=/images/logo.png alt=logo aria-label=logo height=30px>Che's Blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>再次认识V8引擎</h1><div class=post-description></div><div class=post-meta>February 15, 2021</div></header><div class=post-content><blockquote><p>本文于2020.01.03发表到掘金</p></blockquote><h1 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h1><p>最近RN新版本支持了V8引擎，也给我一个契机重新认识V8。本文共有2部分，一部分阐述V8内部的组成和优化技术，另一部分阐述V8和RN的关系。</p><h1 id=解释与编译js在v8的执行过程>解释与编译：JS在V8的执行过程<a hidden class=anchor aria-hidden=true href=#解释与编译js在v8的执行过程>#</a></h1><p>如下图所示，JS在V8的执行过程分为<strong>解释</strong>和<strong>编译</strong>两种模式。</p><p>分为2种模式的原因主要在于：</p><ol><li>把JS源码解释为字节码，减少机器码占用的内存空间，牺牲时间换空间</li><li>优先进行解释，提高代码的启动速度</li><li>针对特定的方法（例如高频调用），JIT编译为机器码，保证运行性能</li><li>分层解释与编译，保证V8可维护性</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b70ff6d33102?w=1019&h=764&f=png&s=54324" alt=v8-pipeline.png></p><p>如果考虑垃圾回收，执行过程也可以这样表示。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b712ba8c9e97?w=1714&h=902&f=png&s=63564" alt=v8-pipeline-gc.png></p><h2 id=解释器-ignition>解释器 Ignition<a hidden class=anchor aria-hidden=true href=#解释器-ignition>#</a></h2><p>解释器的输入是JS源码，输出是字节码（bytecode）。同时，还会输出Feedback Vector。</p><p>像其他解释器一样，Ignition先根据源码构建AST，接着把AST转换成bytecode，最终在VM上解释运行。</p><h3 id=设计bytecode>设计bytecode<a hidden class=anchor aria-hidden=true href=#设计bytecode>#</a></h3><p>在设计bytecode时，Ignition采用了Registry Machine来表示bytecode。由于bytecode是机器码的一种抽象表示，因此以Registry Machine的形式表示bytecode，可以让bytecode自然而然地被解释运行。</p><p>Ignition使用了r0，r1，r2……和一个acc加法寄存器。</p><p>举例：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b718af204009?w=995&h=412&f=png&s=92335" alt=ignition-bytecode.png></p><p>注意看 <code>LdaNamedProperty a0, [0], [4]</code>，LdaNamedProperty对应着读取obj.x的行为，其中，a0映射到obj，[0]映射到x，[4]映射到Feedback Vector，用来做性能优化。</p><h3 id=feedback-vector>Feedback Vector<a hidden class=anchor aria-hidden=true href=#feedback-vector>#</a></h3><p>Ignition在解释JS源码时，会构建Feedback Vector，并共享给TurboFan。Feedback的结构主要包括4点：</p><ol><li>SharedFunctionInfo：闭包的描述信息</li><li>Invocation count: 代表这个闭包被执行的次数</li><li>Optimized Code: 标记是否存在TurboFan编译出来的优化代码</li><li>BinaryOp：记录了闭包输入输出的类型</li></ol><p>举例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
}
<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</code></pre></div><pre><code> - feedback vector: 0xb5101eaa091: [FeedbackVector] in OldSpace
 - length: 1
 SharedFunctionInfo: 0xb5101ea99c9 &lt;SharedFunctionInfo add&gt;
 Optimized Code: 0
 Invocation Count: 1
 Profiler Ticks: 0
 Slot #0 BinaryOp BinaryOp:SignedSmall
</code></pre><p>注意看<code>BinaryOp:SignedSmall</code>，它的含义是返回了SignedSmall类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>;
}
<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1.1</span>, <span style=color:#ae81ff>2.2</span>);
</code></pre></div><pre><code> - feedback vector: 0x3fd6ea9ef9: [FeedbackVector] in OldSpace
 - length: 1
 SharedFunctionInfo: 0x3fd6ea9989 &lt;SharedFunctionInfo add&gt;
 Optimized Code: 0
 Invocation Count: 2
 Profiler Ticks: 0
 Slot #0 BinaryOp BinaryOp:Number
</code></pre><p>当我们用不同的参数再次调用add方法后，Feedback Vector产生了变化。<code>BinaryOp:Number</code>变成了Number。由于JS是动态类型语言，做加法是会做类型转换，因此Feedback Vector会认为它降级到了Number类型。</p><p>Feedback Vector是非常重要的描述信息，它描述了编译优化这个闭包的优先级（Invocation Count），以及闭包的数据类型（BinaryOp）。这些信息将被作为TurboFan的输入，编译优化bytecode。</p><h2 id=编译器-turbofan>编译器 TurboFan<a hidden class=anchor aria-hidden=true href=#编译器-turbofan>#</a></h2><p>编译器的输入是bytecode + Feedback Vector，输出是机器码（machine code）</p><h3 id=类型推断speculative-optimization>类型推断（Speculative Optimization）<a hidden class=anchor aria-hidden=true href=#类型推断speculative-optimization>#</a></h3><p>类型推断是TurboFan的核心思想。由于JS是动态类型语言，准确对参数做类型推断，能够从2方面改善性能：</p><ol><li>读取字段：读取<code>obj.x</code>时，如果能推断obj的类型，就能直接知道x在内存中的偏移量，减少寻址次数；</li><li>类型转换：<code>a + b</code>时，JS会做类型转换，包含一系列的判断逻辑。如果能推断a、b的类型，就能跳过不必要的逻辑。</li></ol><h3 id=编译过程>编译过程<a hidden class=anchor aria-hidden=true href=#编译过程>#</a></h3><p>在Ignition构造bytecode和Feedback Vector后，TurboFan可以生成机器码了。</p><p>总体流程如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b71c9558b645?w=931&h=549&f=png&s=20174" alt=turbofan-pipeline.png></p><p>在编译器前端，bytecode以Sea of Nodes的形式表达，再生成内联。</p><p>在机器码优化阶段，会做传统优化、消除冗余、逃逸分析、表示选择。</p><p>在编译器后端，主要在机器层面做机器码的再次优化和调度执行。</p><p>此外，从V8源码和一些论文中，我们发现TurboFan会使用LLVM、Emscripten、Binaryen、WABT作为JIT编译器。</p><p>Sea of Nodes示例：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b71f54a3ab22?w=1182&h=1144&f=png&s=80911" alt=sea-of-nodes.png></p><h2 id=编译优化技术>编译优化技术<a hidden class=anchor aria-hidden=true href=#编译优化技术>#</a></h2><p>把Ignition和TurboFan结合起来，V8可以实现的编译优化技术包括： Hidden Class， Inline Caching， OSR（On Stack Replacement）</p><h3 id=hidden-class-隐藏类>Hidden Class 隐藏类<a hidden class=anchor aria-hidden=true href=#hidden-class-隐藏类>#</a></h3><p>Hidden Class就是著名的鸭子模型。Hidden Class是动态创建的，<strong>按照配置属性的顺序</strong>，以链式构造一系列Hidden Class。举例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Point</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span>;
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span>;
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Point</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Point</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
</code></pre></div><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b7225f30bad1?w=1024&h=768&f=png&s=68937" alt=hidden-class.png></p><p>若用不同的顺序配置同名属性，实际上会构造不同的Hidden Class。因此，按顺序配置属性式很重要的工作。</p><h3 id=inline-caching-内联缓存>Inline Caching 内联缓存<a hidden class=anchor aria-hidden=true href=#inline-caching-内联缓存>#</a></h3><p>通常，访问对象属性的过程是：Step1 获取Hidden Class的地址，Step2 根据属性名查找偏移量，Step3 从该属性的地址访问数据。</p><p>虽然Hidden Class使引擎无需遍历所有属性，但仍然比较耗时。</p><p>Inline Caching的思路就是将上一次访问的Hidden Class和偏移量缓存起来，当下次访问时，V8断言Hidden Class和字段名和上次访问相同，直接尝试访问对应的地址。因此提高了性能。若断言失败，则回退到一般方式。</p><h3 id=osr-on-stack-replacement>OSR (On Stack Replacement)<a hidden class=anchor aria-hidden=true href=#osr-on-stack-replacement>#</a></h3><p>有时候，V8会执行一些耗时非常长的方法。因此编译后的代码可能会在方法结束之前就被编译出来。那么，V8会把执行到一半的上下文，用OSR技术发送给编译后的代码，并继续执行。这部分逻辑比较复杂，可以参考：https://wingolog.org/archives/2011/06/20/on-stack-replacement-in-v8</p><h2 id=内存管理-与-垃圾回收>内存管理 与 垃圾回收<a hidden class=anchor aria-hidden=true href=#内存管理-与-垃圾回收>#</a></h2><p>和Java GC相似，V8使用了年轻代和年老代来实现GC。</p><p>年轻代中的GC主要采用Scavenge算法，通过复制对象实现GC。</p><blockquote><p>它将Heap分为2个semi space，一个处于使用中（From），一个处于空闲（To）。</p><p>分配对象时，在From空间中分配；GC时，把From空间中存活的对象复制到To空间，并释放From的非存活对象，复制完成后，From和To互换。从GC根节点开始遍历，按照引用来标记存活的对象。</p><p>当对象经过几次GC后仍然存活，或To空间的内存占用超过限制，年轻代的对象会晋升到年老代</p></blockquote><p>年老代中的GC主要用标记-清除法。</p><blockquote><p>标记过程与年轻代的标记过程相同，遍历GC Root做标记。</p><p>清除过程把所有非存活的对象释放。</p></blockquote><h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2><p>fast / slow properties</p><p>功能扩展</p><p>V8 Debug工具</p><p>快照</p><p>wasm</p><h2 id=其他refs>其他Refs<a hidden class=anchor aria-hidden=true href=#其他refs>#</a></h2><p><a href=https://fhinkel.rocks/2017/08/16/Understanding-V8-s-Bytecode/>https://fhinkel.rocks/2017/08/16/Understanding-V8-s-Bytecode/</a></p><p><a href=https://zhuanlan.zhihu.com/p/28590489>https://zhuanlan.zhihu.com/p/28590489</a></p><p><a href="https://docs.google.com/presentation/d/1chhN90uB8yPaIhx_h2M3lPyxPgdPmkADqSNAoXYQiVE/edit#slide=id.g1357e6d1a4_0_58">https://docs.google.com/presentation/d/1chhN90uB8yPaIhx_h2M3lPyxPgdPmkADqSNAoXYQiVE/edit#slide=id.g1357e6d1a4_0_58</a></p><p><a href=https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8>https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8</a></p><p><a href=https://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition>https://benediktmeurer.de/2017/03/01/v8-behind-the-scenes-february-edition</a></p><p><a href=https://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E/edit>https://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E/edit</a></p><p><a href=https://codeburst.io/node-js-v8-internals-an-illustrative-primer-83766e983bf6>https://codeburst.io/node-js-v8-internals-an-illustrative-primer-83766e983bf6</a></p><p><a href=https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e>https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e</a></p><p><a href=https://zhuanlan.zhihu.com/p/27628685>https://zhuanlan.zhihu.com/p/27628685</a></p><h1 id=v8-与-react-native>V8 与 React Native<a hidden class=anchor aria-hidden=true href=#v8-与-react-native>#</a></h1><h2 id=react-native模块概述>React Native模块概述<a hidden class=anchor aria-hidden=true href=#react-native模块概述>#</a></h2><p>下图右侧是新版React Native的架构图，可以看到，React JS代码经过JSI解释，下发给Fabric、Turbo Modules，最终在Native上执行。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b724cf33b219?w=1884&h=914&f=png&s=179585" alt=react-native-next.png></p><h2 id=v8-与-jsi-javascript-interface>V8 与 JSI (JavaScript Interface)<a hidden class=anchor aria-hidden=true href=#v8-与-jsi-javascript-interface>#</a></h2><p>JSI是一个精简的JS引擎接口：</p><blockquote><p>与其使用桥来做消息传递，新的架构允许开发者直接“调用”Java/ObjC的方法（类似RPC）。</p><p>就像我们在浏览器调用DOM方法一样，如果声明<code>var el = document.createElement('div');</code>，变量el是一个C++实现的引用，而不是JS对象。当JS调用<code>el.setAttribute('width', 100)</code>，浏览器同步调用了C++的setWidth方法，最终改变了元素的宽度。</p><p>在React Native中，我们同样使用了JSI来调用Java/ObjC方法。</p></blockquote><p>RN实现了基本的JS Runtime：https://github.com/facebook/react-native/blob/master/ReactCommon/jsi/jsi/jsi.h</p><p>可以需要开发Native模块，来丰富JSI的能力，例如：http://blog.nparashuram.com/2019/01/react-natives-new-architecture-glossary.html#jsi</p><p>在此基础上，我们就可以用V8Runtime来继承默认的JS Runtime！！！例如：https://github.com/Kudo/react-native-v8/blob/master/src/v8runtime/V8Runtime.h</p><p>C++: truly cross-platform language 😂</p><h2 id=v8与hermes>V8与Hermes<a hidden class=anchor aria-hidden=true href=#v8与hermes>#</a></h2><p>Hermes的设计目标：针对移动端RN应用做性能优化，降低：</p><ol><li><p>App可用时间（TTI）：提升一倍时间效率，Stock RN 4.30s，Hermes RN 2.01s</p></li><li><p>包大小：减少50%的大小，Stock RN 41mb，Hermes RN 22mb</p></li><li><p>内存利用率：节省30%的内存使用，Stock RN 185mb，Hermes RN 136mb</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/1/3/16f6b7272b79cee6?w=1676&h=846&f=png&s=196349" alt=hermes.png></p><p>关键设计思想：移动端的特点是较小的RAM和较慢的flash IO，因此RN团队决定在build阶段改进Parse和Compile！</p><ol><li><p>字节码预编译：按需加载字节码，改善TTI；内存以只读方式映射 ，改善内存占用</p></li><li><p>无JIT编译器：改善TTI、内存消耗，用强大的解释器弥补缺少JIT编译器的损失</p></li><li><p>垃圾回收策略：按前两点的需求改进垃圾回收策略，同时每次GC不扫描整个JS Heap，减少GC时间</p></li></ol><p>Hermes 和 V8 的一些性能对比：<a href=https://www.infoq.cn/article/ZPhAQPA0uqKyb5hT*i3p>https://www.infoq.cn/article/ZPhAQPA0uqKyb5hT*i3p</a></p><h2 id=其他refs-1>其他Refs<a hidden class=anchor aria-hidden=true href=#其他refs-1>#</a></h2><p><a href=https://formidable.com/blog/2019/jsi-jsc-part-2/>https://formidable.com/blog/2019/jsi-jsc-part-2/</a></p><p><a href=https://engineering.fb.com/android/hermes/>https://engineering.fb.com/android/hermes/</a></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://blog.chezs.me/>Che's Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>